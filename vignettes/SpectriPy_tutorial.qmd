---
title: "SpectriPy tutorial: Annotation of LC-MS/MS spectra"
bibliography: SpectriPy_tutorial.bib
vignette: >
  %\VignetteIndexEntry{SpectriPy tutorial: Annotation of LC-MS/MS spectra}
  %\VignetteKeywords{Mass Spectrometry, MS, MSMS, Metabolomics, Infrastructure, Quantitative}
  %\VignettePackage{SpectriPy}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{quarto::html}
  %\VignetteDepends{Spectra,BiocStyle,SpectriPy,reticulate,MsBackendMgf,msdata,mzR}
---

**Compiled**: `r date()`

# Introduction

*SpectriPy* enables powerful mass spectrometry (MS) data analysis workflows
combining the strengths of Python and R MS libraries. 
The concepts and examples can be checked by performing some steps from the 
package’s vignette, from source 
https://rformassspectrometry.github.io/SpectriPy/articles/SpectriPy.html.

To showcase the strength
of combining functionalities from both programming languages with *SpectriPy*,
we perform the annotation of LC-MS/MS spectra using a reference library.
During the tutorial, we use different spectral similarity algorithms from both R
and Python: normalized dot product similarity from Spectra
[@rainer_modular_2022], CosineGreedy from matchms [@huber_matchms_2020], 
Tanimoto score predictions from MS2DeepScore, XX. FINDME!!! TODO

The spectral reference library used in this tutorial originates from the GNPS
repository (provided in mgf format), which can easily be replaced by the user by
other public spectral databases or with an in-house reference database.
Similarily, the spectral similarity algorithms used in this tutorial, can easily
be extended to other R/python spectral silimilatity algorithms. 


# steps to do = to be removed TODO

Potential example: annotation of LC-MS/MS
+R: Perform LC-MS/MS data preprocessing in R with xcms } part in the metabonaut already
+R: Extract MS2 spectra for features as a Spectra object-    } idem, so maybe refer and load ‘res’ instead? 
-load/make query ==> test/rdata depending vignette? TODO
+Python: Load reference database, e.g. from a GNPS MGF file
+R: translate Spectra object to Python.
+Python: process and filter the data, both the reference database and the experimental data = filtering
+Python: calculate pairwise similarity (= CosineGreedy from matchms) between the experimental spectra and reference.
-py: others cals...!!! TODO
-more from matchms?? cross-language-ms-analysis.qmd for other examples. TODO
-py bugs in retic!!!! TODO
+py/r: table with the top1 found names of molec for the query???
-R: translate back to R !!! TODO
+R: plot
-at end (how?), put data in vignette IN package, now via explicit path pc... TODO

# Load SpectriPy

Load required R SpectriPy package.

```{r}
#| warning: false
#' R session:

library(SpectriPy)
```


# Load query MS2 data

for now, select only needed FINDME and describe. TODO: vignette with test, 
metabonaut with load

## Test MS2 data

For this, we first make some test data with 2 MS2 spectra from 2 unknown 
compounds each. In total, we have 4 spectra.

```{r}
#| warning: false
#' R session:

#' R MS package
library(Spectra)

#' Create a Spectra object with two MS2 spectra for unknown compound 1 
#' (== Caffeine).
caf <- DataFrame(
    feature_id = c("FT01", "FT01"),
    msLevel = c(2L, 2L),
    precursorMz = c(195.0877, 195.0877),
    #id = 'HMDB0001847',   
    #name = "Caffeine",
    #smiles = 'CN1C=NC2=C1C(=O)N(C(=O)N2C)C',
    #inchi = '1S/C8H10N4O2/c1-10-4-9-6-5(10)7(13)12(3)8(14)11(6)2/h4H,1-3H3',
    parent_mass = 195.08
)
caf$intensity <- list(
    c(340.0, 416, 2580, 412),
    c(388.0, 3270, 85, 54, 10111))
caf$mz <- list(
    c(135.0432, 138.0632, 163.0375, 195.0880),
    c(110.0710, 138.0655, 138.1057, 138.1742, 195.0864))
caf <- Spectra(caf)

#' Create a Spectra object with two MS2 spectra for for unknown compound 2 
#' (== 1-Methylhistidine)
mhd <- DataFrame(
    feature_id = c("FT02", "FT02"),
    msLevel = c(2L, 2L),
    precursorMz = c(170.0924, 170.0924),
    #id = c("HMDB0000001", "HMDB0000001"),
    #name = c("1-Methylhistidine", "1-Methylhistidine"),
    #smiles = 'CN1C=C(N=C1)C[C@@H](C(=O)O)N',
    #inchi = '1S/C7H11N3O2/c1-10-3-5(9-4-10)2-6(8)7(11)12/h3-4,6H,2,8H2,1H3,(H,11,12)/t6-/m0/s1',
    parent_mass = 170.09)
mhd$mz <- list(
    c(109.2, 124.2, 124.5, 170.16, 170.72),
    c(83.1, 96.12, 97.14, 109.14, 124.08, 125.1, 170.16))
mhd$intensity <- list(
    c(3.407, 47.494, 3.094, 100.0, 13.240),
    c(6.685, 4.381, 3.022, 16.708, 100.0, 4.565, 40.643))
mhd <- Spectra(mhd)


#' Merge the 2 Spectra objects, containing 2 spectra each into 1 search query 
#' Spectra object (== 2 spectra from caf and 2 spectra from 1-methylhis)
ms2_ctr_fts <- c(caf, mhd)
head(ms2_ctr_fts)

#' Print the feature_id of the first spectrum
ms2_ctr_fts$feature_id[1]
```


## Query MS2 data with significant features

The LC-MS/MS query data used in this tutorial, are derived from the Metabonaut 
resource [@louail_metabonaut_2025]. Introduction and a thorough description of the preliminariry 
steps performed are described there, from source
[A Complete End-to-End Workflow for untargeted LC-MS/MS Metabolomics Data Analysis in R](https://rformassspectrometry.github.io/Metabonaut/articles/end-to-end-untargeted-metabolomics.html).

First, we load the MS2 spectra of the unknown features found to be significant 
after the "Differential abundance analysis", see section 
[MS2-based annotation](https://rformassspectrometry.github.io/Metabonaut/articles/end-to-end-untargeted-metabolomics.html#differential-abundance-analysis).

```{r}
#| warning: false
#' R session:

#' R MS package
library(Spectra)

#' Load the MS2 spectra of significant features
load('/home/mdegraeve/Documents/Files/Work_Eurac/Projects/SpectriPy/spectra_significant_fts.RData') #object is ms2_ctr_fts
head(ms2_ctr_fts)

#' Print the available metadata, stored in the Spectra object
spectraVariables(ms2_ctr_fts)

#' Print the feature_id of the first spectrum
ms2_ctr_fts$feature_id[1]
```


# Filter query data

To ensure this `Spectra` object only contains MS2 data, we filter to only MS2 
spectra with more than 2 fragment peaks per spectrum.

```{r}
#' R session:

#' Filter MS2 level data
ms2_ctr_fts <- filterMsLevel(ms2_ctr_fts, 2L)

#' filter minimum 3 fragment peaks
ms2_ctr_fts <- ms2_ctr_fts[lengths(ms2_ctr_fts) >= 3]
head(ms2_ctr_fts)
```


# Load reference MS2 data

## GNPS spectral library

The MS2 spectral reference library in this tutorial originates
from the GNPS repository, and is provided as an MGF formatted file. 
To load other file formats, see 
[link](https://matchms.readthedocs.io/en/latest/api/matchms.importing.html)

```{python}
#| eval: false
#| warning: false
#'' Python session:

from matchms.importing import load_from_mgf

# Read spectra from an MGF formatted file
mgf_py = list(load_from_mgf("/home/mdegraeve/Documents/Files/Work_Eurac/Projects/SpectriPy/inst/extdata/mgf/pesticides.mgf"))
```


## *In-house* spectral library

We import a test data file in
MGF format using the Python *matchms* library. This MGF file is provided within
the *SpectriPy* package so we first define its file name and path in R. The 
loaded object is a Python's `Spectrum` object.

```{python}
#| warning: false
#' Python session:

from matchms.importing import load_from_mgf

# Read spectra from an MGF formatted file, as Spectrum object
mgf_py = list(load_from_mgf("/home/mdegraeve/Documents/Files/Work_Eurac/Projects/SpectriPy/inst/extdata/mgf/test.mgf"))

#' Nr of spectra
len(mgf_py)

#' Access the first spectrum
mgf_py[0]
```

Note that we can also the first spectrum from an R session, by starting the 
command with `py$`.

```{r}
#' R session:

#' Access the first spectrum
py$mgf_py[[1]]
```


# Translate query from R Spectra to py Spectrum

## Conversion of MS2 data to Spectrum object

First, we check if the r Spectra object containing the query MS2 data can be 
accessed in python using the 'r.' prefix.

```{python}
#' Python session:

# check if the r Spectra object can be accessed in python using the 'r.' 
# prefix
r.ms2_ctr_fts
```

Second, we translate the Spectra 
object 'ms2_ctr_fts' to the py Spectrum object 'ms2_ctr_fts_py'.

```{r}
#' R session:

#' Add mapping for additional spectra variables to the default mapping in R and
#' python, respectively
map = c(defaultSpectraVariableMapping(), 
        feature_id = 'feature_id')

#' Convert to py Spectrum
#' pass via 'mapping' the "r = 'py'" translation
system.time(
    ms2_ctr_fts_py <- rspec_to_pyspec(ms2_ctr_fts, mapping = map) 
)
ms2_ctr_fts_py
```

Third, we check if the R convertend Spectrum object can be accessed in python 
using the 'r.' prefix.

```{python}
#' Python session:

# check if the "r convertend Spectrum" object can be accessed in python using 
# the 'r.' prefix
r.ms2_ctr_fts_py
```


# Filter py Spectrum reference library

Before we run the spectral comparisons of our query data to the MGF reference
library, we apply some filtering from matchms. Default filtering was performed 
to standardize ion mode, correct charge and more. See the 
[matchms filtering documentation](https://matchms.readthedocs.io/en/latest/api/matchms.filtering.html).

```{python}
#| warning: false
#' Python session:

from matchms.filtering import default_filters, normalize_intensities

# Apply filters to clean and enhance each spectrum
clean_mgf_py = []
for spectrum in mgf_py:
    # Apply default filter to standardize ion mode, correct charge and more.
    # Default filter is fully explained at https://matchms.readthedocs.io/en/latest/api/matchms.filtering.html
    spectrum = default_filters(spectrum)
    # Scale peak intensities to maximum of 1
    spectrum = normalize_intensities(spectrum)
    clean_mgf_py.append(spectrum)

#' Nr of spectra
len(clean_mgf_py)
```


# Evaluation of different spectral similarity algorithms

We calculate the pairwise similarity between the query spectra and the
reference library spectra using different approaches, using spectral 
objects (Spectra, Spectrum) accross both languages and using algoritms from
multiple libraries.


## CosineGreedy from matchms

next, we calculate the pairwise similarity between the query spectra and the
reference library spectra using Python's matchms.

Here, we use the spectral similarity algorithm CosineGreedy from matchms, from 
source [matchms](https://github.com/matchms/matchms/blob/master/README.rst).  
This algorithm can easily be exchanged for another spectral similarity 
calculation from matchms. See 
[here](https://matchms.readthedocs.io/en/latest/api/matchms.similarity.html) 
for other similarity score methods.

```{python}
#' Python session:

from matchms import calculate_scores
from matchms.similarity import CosineGreedy

# Calculate Cosine similarity scores between all spectra
# For other similarity score methods see https://matchms.readthedocs.io/en/latest/api/matchms.similarity.html
similarity_score = CosineGreedy(tolerance = 0.1)  # Change this for other algorithm
scores = calculate_scores(references = clean_mgf_py,
                          queries = r.ms2_ctr_fts_py,
                          similarity_function = similarity_score)
scores
```


### Evaluation

 From the calculated spectral similarity scores, we rearange the data to 
 make a dataframe containing the best matched compound name (derived from the 
 reference library) per queried spectrum.

First, we extract and transpose the scores as a python array. Each row of the 
array will contain the similarity scores of one spectrum from our query spectra 
`r.ms2_ctr_fts_py` against the cleaned reference library `clean_mgf_py`. 

```{python}
#' Python session:

# Convert to array and transpose
sim_matchms = scores.to_array()["CosineGreedy_score"]
sim_matchms = sim_matchms.T

# Contains 1 row for each spectrum in query 
sim_matchms.shape
```

Next, we create a dataframe with per queried spectrum from our unknown 
variables, the compound name of the higest matching spectra from the reference 
library and the corresponding similarity score.

```{python}
#' Python session:

# not correct when run through reticulate... TODO FINDEME!!!! sure correct code!!!!!!

import numpy as np
import pandas as pd

# Prepare results list
results = []
for i in range(sim_matchms.shape[0]):

    #row is the query, keep nr in the results instead of replacing by eg id
    name_row = r.ms2_ctr_fts_py[i].get('feature_id') 
    
    row_values = sim_matchms[i].copy()
    
    # match with higest col nr from the references
    max_col = np.argmax(row_values)  # Find column index of max value
    max_value = row_values[max_col]  # Get max value

    # replace the nr of refererences with the name
    name_max_col = clean_mgf_py[max_col].get('compound_name') 

    results.append({"query": i + 1, #count from 1
                    "query_feature_id": name_row, 
                    "reference": max_col,
                    "reference_compound_name": name_max_col, 
                    "CosineGreedy_score": max_value})

# Convert to DataFrame
df = pd.DataFrame(results)

# Print the full DataFrame
df
```

[!] **Caution**: 
As the higest score is taken as criteria for the annotation, a lot of 
caution is needed evaluation the trueness of the match. A low score is not 
reliable, as the similarity algorithm will calculate a score for each pairwise 
pair. Therefore, a match will alsways be found. In addition, if you unknown 
compound is absent in the reference library, it will match wrongly to another 
compound that is present in the database.

To ensure blindly using the above dataframe, we apply a filter of 0.7 below the 
MS2 spectral matching is deemed unrealiable. Above this value, the potential 
annotations need to be validated using e.g. rerunning samples in the presence of
commercial standards. 

```{python}
#' Python session:

# Keep only rows where score > 0.7
df_filtered = df[df["CosineGreedy_score"] > 0.7]

# Print the filtered DataFrame
df_filtered
```

Regarding our first unknown feature FT01, which are actually 2 MS2 spectra from 
caffeine, we see that the higest match of the 1st and 2nd spectra are both 
matched correctly (Cosine Greedy scores 1.00 and 0.99) to the spectra of 
caffeine in the in-house spectral library.

In the case of our second unknown feature FT02, no trustworthy matches were 
made. This spectra is was actually derived from 1-Methylhistidine, which is not 
present in the in-house spectral library. Therefore, no matches should be found.

To visually inspect how well the query qnd reference spectra match, we refer to 
the [Metabonaut resource](https://rformassspectrometry.github.io/Metabonaut/articles/end-to-end-untargeted-metabolomics.html) on how to generate the mirror plots.


## Dot product from Spectra

Here, we calculate the pairwise similarity between the query spectra and the
reference library spectra using R's Spectra.

In R we can use the `compareSpectra()` function that by default calculates the
normalized dot product similarity between the compared spectra. The MS data from
the mzML file was processed in Python. To use this data we first create a
`Spectra` object with a `MsBackendPy` backend. See the 
[SpectriPy vignette](https://rformassspectrometry.github.io/SpectriPy/articles/SpectriPy.html) 
for more information regarding calculation performance and (memory) efficiency.

```{r}
#' R session:

#' R MS package
library(Spectra)

#' Create a Spectra object with a MsBackendPy backend for the
#' attribute "clean_mgf_py"
clean_mgf_r <- Spectra("clean_mgf_py", source = MsBackendPy())

#' Calculate the pairwise similarity between spectra
sim_spectra <- compareSpectra(clean_mgf_r, #reference
                              ms2_ctr_fts,  #query
                              tolerance = 0.1)

#' Transpose to add to results table
sim_spectra <- t(sim_spectra)
dim(sim_spectra)
```


## Evaluation

To evaluate, we rearange and filter the MS2 spectral similarity matrix as in the 
previous section, only using R this time.

```{r}
#' R session:

# Initialize results dataframe
results <- data.frame(query = numeric(), query_feature_id = character(), 
                      reference = numeric(), 
                      reference_compound_name = character(), 
                      dot_score = numeric(), stringsAsFactors = FALSE)

# Loop over rows to find highest value
for (i in 1:nrow(sim_spectra)) {
  row_values <- sim_spectra[i, ]
  
  #row is the query, keep nr in the results instead of replacing by eg id
  name_row = ms2_ctr_fts$feature_id[i]

  max_col <- which.max(row_values)  # Find column index of max value, ! r counts from 1
  max_value <- row_values[max_col]  # Extract max value
  
  # replce the nr of refererences with the name
  name_max_col = clean_mgf_r$compound_name[max_col] #check count in R from 1

  results <- rbind(results, data.frame(query = i, 
                                       query_feature_id = name_row,
                                       reference =  max_col,
                                       reference_compound_name = name_max_col, 
                                       score = max_value))
}

# Keep only ows where score > 0.7
results <- results[results$score > 0.7, ]

# Print the results
print(results)
```

The same results, with small deviation score values, are found for the test 
data with 2 unknown features.


## Tanimoto score from MS2DeepScore

Here, we calculate the pairwise similarity between the query spectra and the
reference library spectra using R's Spectra. FINDME!!!


# Compare similarity scores

To conclude, we want to see how much the spectral similarity scores differ 
between the different algoritms preformed above. The score matrix from matchms
is stored in the Python object `sim_matchms` and the score matrix from spectra
in R's `sim_spectra`.

```{r}
#' R session:

#' Plot the similarity scores against each other
plot(py$sim_matchms, sim_spectra, pch = 21, col = "#000000ce", bg = "#00000060",
     xlab = "Cosine Greedy", ylab = "Dot product")
grid()

```


# Adding annotated spectra to R

After thorough inspection, we decide that we want to add the putative 
annotation of the first feature to our test data. We add this information in 
the originally made R Spectra object. As both object are loaded twice, both an
R Spectra object `ms2_ctr_fts` and a Python Spectrum object `r.ms2_ctr_fts_py`, 
this new info will only be added in the original Spectra object.

```{r}
#' R session:

#' Print the feature_id of the first spectrum
#ms2_ctr_fts$name[1] <- "Caffeine" #FINDME, how to add??

#spectraVariables(ms2_ctr_fts)

    #id = 'HMDB0001847',   
    #name = "Caffeine",
    #smiles = 'CN1C=NC2=C1C(=O)N(C(=O)N2C)C',
    #inchi = '1S/C8H10N4O2/c1-10-4-9-6-5(10)7(13)12(3)8(14)11(6)2/h4H,1-3H3',

```


# Session information

```{r}
#' R session:

sessionInfo()
```


# References
